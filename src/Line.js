import {Text} from "./Text.js";
import {randomID, isBetween, getDist} from "./sky-helpers.js";

const IDLENGTH = 16;

/**
    @param {object} args Object-like object of input arguments.
    @param {list} args.points List of {@link Point} constructor argument objects
    @param {string} [args.color="black"]
    @param {float} [args.width=1]
    @param {boolean} [args.answer=false]
    @param {boolean} [args.correctanswer=false]
    @param {object} [args.fill] Fill the region enclosed by the line
    @param {string} args.fill.color Color to fill the region
    @param {float} args.fill.opacity Opacity of the color (0 to 1)
    @param {object} [args.label] Label to go beside the line
    @param {string} [args.label.text] Label contents
    @param {number} [args.label.independent] Location of text (of independent variable)
    @param {number} [args.label.dependent] Location of text (of dependent variable)
*/
export class Line {
    constructor(args) {
        /**
            @name Line#ID
            @type string
            @desc (Probably) unique identifier for line. Generated by {@link randomID}.
        */
        this.ID = randomID(IDLENGTH);
        /**
            @name Line#color
            @type string
            @default "black"
            @desc Line color.
        */
        this.color = "black";
        /**
            @name Line#width
            @type number
            @default 2
            @desc Line width.
        */
        this.width = 2;
        /**
            @name Line#tension
            @type number
            @default 0
            @desc Tension of spline drawn through points (0 is linear)
        */
        this.tension = 0;
        /**
            @name Line#answer
            @type boolean
            @default false
            @desc Is this line submitted as an answer to the question?
        */
        this.answer = false;
        /**
            @name Line#correctanswer
            @type boolean
            @default false
            @desc Is this line a correct answer?
        */
        this.correctanswer = false;
        // Fill values from provided arguments
        for (let key of Object.keys(args)) {
            this[key] = args[key];
        }
    }

    draw(context) {
        context.save();
        context.beginPath();
        context.globalAlpha = 1;
        context.strokeStyle = this.color;
        context.lineWidth = this.width;
        if (this.dashes) {
            context.setLineDash([this.dashes.dash, this.dashes.space]);
        }
        let first = true;
        // Connect points
        if (this.tension == 0) {
            // Draw point-to-point
            for (let pt of this.points) {
                if (isBetween(pt.rawx, this.graphinfo.graphleft, this.graphinfo.graphright) &&
                    isBetween(pt.rawy, this.graphinfo.graphtop, this.graphinfo.graphbottom)) {
                    if (first) {
                        // Move to start of line
                        context.moveTo(pt.rawx, pt.rawy);
                    } else {
                        // Draw segment
                        context.lineTo(pt.rawx, pt.rawy);
                        context.stroke();
                    }
                    first = false;
                }
            }
        } else {
            this.drawSpline(context, this.tension);
        }
        // Shade tolerance of points
        for (let pt of this.points) {
            if (this.correctanswer && pt.answer) {
                // Draw ellipse
                context.beginPath();
                context.strokeStyle = "green";
                context.ellipse(pt.rawx, pt.rawy, this.tolerance.x*pt.graphinfo.x.scale, this.tolerance.y*-pt.graphinfo.y.scale, 0, 0, 2*Math.PI, false);
                //context.stroke();
                // Fill circle
                context.fillStyle = "green";
                context.globalAlpha = 0.3;
                context.fill();
            }
        }
        if (this.fill) {
            context.fillStyle = this.fill.color;
            context.globalAlpha = this.fill.opacity;
            context.fill();
        }
        if (this.label) {
            let pos = {"graphinfo": this.graphinfo};
            pos[this.independent] = this.label.independent;
            pos[this.dependent] = this.label.dependent;
            new Text({
                "text": this.label.text,
                "position": pos,
                "align": "center",
                "color": this.color,
                "rotate": this.label.rotate
            }).draw(context);
        }
        context.restore();
    }
    getControlPoints(x0,y0,x1,y1,x2,y2,t){
        //  x0,y0,x1,y1 are the coordinates of the end (knot) pts of this segment
        //  x2,y2 is the next knot -- not connected here but needed to calculate p2
        //  p1 is the control point calculated here, from x1 back toward x0.
        //  p2 is the next control point, calculated here and returned to become the
        //  next segment's p1.
        //  t is the 'tension' which controls how far the control points spread.

        //  Scaling factors: distances from this knot to the previous and following knots.
        var d01=Math.sqrt(Math.pow(x1-x0,2)+Math.pow(y1-y0,2));
        var d12=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));

        var fa=t*d01/(d01+d12);
        var fb=t-fa;

        var p1x=x1+fa*(x0-x2);
        var p1y=y1+fa*(y0-y2);

        var p2x=x1-fb*(x0-x2);
        var p2y=y1-fb*(y0-y2);

        return [p1x,p1y,p2x,p2y]
    }
    /**
    *  Using example at: http://scaledinnovation.com/analytics/splines/aboutSplines.html
    */
    drawSpline(context, t) {
        let pts = [];
        for (let pt of this.points) {
            pts.push(pt.rawx);
            pts.push(pt.rawy);
        }
        let cp = [];
        const n = pts.length;
        for(let i = 0; i < n - 4; i += 2) {
            cp = cp.concat(this.getControlPoints(pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5],t));
        }
        for(var i=2;i<pts.length-5;i+=2){
            context.beginPath();
            context.moveTo(pts[i],pts[i+1]);
            context.bezierCurveTo(cp[2*i-2],cp[2*i-1],cp[2*i],cp[2*i+1],pts[i+2],pts[i+3]);
            context.stroke();
            context.closePath();
        }
        //  For open curves the first and last arcs are simple quadratics.
        context.beginPath();
        context.moveTo(pts[0],pts[1]);
        context.quadraticCurveTo(cp[0],cp[1],pts[2],pts[3]);
        context.stroke();
        context.closePath();

        context.beginPath();
        context.moveTo(pts[n-2],pts[n-1]);
        context.quadraticCurveTo(cp[2*n-10],cp[2*n-9],pts[n-4],pts[n-3]);
        context.stroke();
        context.closePath();
    }
    /**
        @return {int} The number of line segments
    */
    segments() {
        return this.points.length-1;
    }
    /**
        @return {float} The total distance covered by the line from point to point
    */
    distance() {
        let sum = 0;
        for (let i = 1; i < this.points.length; i++) {
            sum += getDist(this.points[i-1], this.points[i]);
        }
        return sum;
    }
    /**
        @return {object} The internal data of the line
    */
    data() {
        let r = {};
        for (let k of Object.keys(this)) {
            r[k] = this[k];
        }
        return r;
    }
}
