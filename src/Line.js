import {randomID, isBetween, getDist} from "./sky-helpers.js";

const IDLENGTH = 16;

/**
    @param {object} args Object-like object of input arguments.
    @param {list} args.points List of {@link Point} constructor argument objects
    @param {string} [args.color="black"]
    @param {float} [args.width=1]
    @param {boolean} [args.answer=false]
    @param {boolean} [args.correctanswer=false]
    @param {object} [args.fill] Fill the region enclosed by the line
    @param {string} args.fill.color Color to fill the region
    @param {float} args.fill.opacity Opacity of the color (0 to 1)
    @param {object} [args.label] Label to go beside the line
    @param {string} [args.label.text] Label contents
    @param {number} [args.label.independent] Location of text (of independent variable)
    @param {number} [args.label.dependent] Location of text (of dependent variable)
*/
export class Line {
    constructor(args) {
        /**
            @name Line#ID
            @type string
            @desc (Probably) unique identifier for line. Generated by {@link randomID}.
        */
        this.ID = randomID(IDLENGTH);
        /**
            @name Line#color
            @type string
            @default "black"
            @desc Line color.
        */
        this.color = "black";
        /**
            @name Line#width
            @type string
            @default 2
            @desc Line width.
        */
        this.width = 2;
        /**
            @name Line#answer
            @type boolean
            @default false
            @desc Is this line submitted as an answer to the question?
        */
        this.answer = false;
        /**
            @name Line#correctanswer
            @type boolean
            @default false
            @desc Is this line a correct answer?
        */
        this.correctanswer = false;
        // Fill values from provided arguments
        for (let key of Object.keys(args)) {
            this[key] = args[key];
        }
    }

    draw(context) {
        context.save();
        context.beginPath();
        context.globalAlpha = 1;
        context.strokeStyle = this.color;
        context.lineWidth = this.width;
        if (this.dashes) {
            context.setLineDash([this.dashes.dash, this.dashes.space]);
        }
        let first = true;
        // Connect points
        for (let pt of this.points) {
            if (isBetween(pt.rawx, this.graphinfo.graphleft, this.graphinfo.graphright) &&
                isBetween(pt.rawy, this.graphinfo.graphtop, this.graphinfo.graphbottom)) {
                if (first) {
                    // Move to start of line
                    context.moveTo(pt.rawx, pt.rawy);
                } else {
                    // Draw segment
                    context.lineTo(pt.rawx, pt.rawy);
                    context.stroke();
                }
                first = false;
            }
        }
        // Shade tolerance of points
        for (let pt of this.points) {
            if (this.correctanswer && pt.answer) {
                // Draw ellipse
                context.beginPath();
                context.strokeStyle = "green";
                context.ellipse(pt.rawx, pt.rawy, this.tolerance.x*pt.graphinfo.x.scale, this.tolerance.y*-pt.graphinfo.y.scale, 0, 0, 2*Math.PI, false);
                //context.stroke();
                // Fill circle
                context.fillStyle = "green";
                context.globalAlpha = 0.3;
                context.fill();
            }
        }
        if (this.fill) {
            context.fillStyle = this.fill.color;
            context.globalAlpha = this.fill.opacity;
            context.fill();
        }
        if (this.label) {
            let pos = {"graphinfo": this.graphinfo};
            pos[this.independent] = this.label.independent;
            pos[this.dependent] = this.label.dependent;
            new Text({
                "text": this.label.text,
                "position": pos,
                "align": "center",
                "color": this.color,
                "rotate": this.label.rotate
            }).draw(context);
        }
        context.restore();
    }
    /**
        @return {int} The number of line segments
    */
    segments() {
        return this.points.length-1;
    }
    /**
        @return {float} The total distance covered by the line from point to point
    */
    distance() {
        let sum = 0;
        for (let i = 1; i < this.points.length; i++) {
            sum += getDist(this.points[i-1], this.points[i]);
        }
        return sum;
    }
    /**
        @return {object} The internal data of the line
    */
    data() {
        let r = {};
        for (let k of Object.keys(this)) {
            r[k] = this[k];
        }
        return r;
    }
}
